#  پشت پرده ی آموزش یک مدل تشخیص دهنده‌ی ارقام
---
## مفاهیم بنیادین بینایی کامپیوتر - The Foundations of Computer Vision
<img src='https://datasets.activeloop.ai/wp-content/uploads/2019/12/MNIST-handwritten-digits-dataset-visualized-by-Activeloop.webp'>
برای درک اتفاقی که در یک مدل بینایی کامپیوتری رخ می‌دهد، ابتدا باید فهمید چگونه کامپیوترها با تصاویر برخورد می‌کنند. ما از یکی از معروف‌ترین مجموعه‌های داده در بینایی کامپیوتری، یعنی MNIST، برای آزمایشات خود استفاده خواهیم کرد. MNIST شامل تصاویری از اعداد دستی است که توسط موسسه ملی استانداردها و فناوری (NIST) جمع‌آوری شده‌اند و سپس توسط Yann Lecun و همکارانش به عنوان یک مجموعه داده یادگیری ماشین مرتب‌سازی شده‌اند. Lecun در سال 1998 از MNIST در LeNet-5 استفاده کرد، اولین سیستم کامپیوتری که تشخیص عملیاتی از دنباله‌های رقم دستی را نشان داد. این یکی از مهمترین پیشرفت‌ها در تاریخ هوش مصنوعی بود.
برای این آموزش اولیه، فقط قصد داریم یک مدل بسازیم که هر تصویر را به عنوان 3 یا 7 طبقه‌بندی کند. پس بیایید نمونه‌ای از MNIST را که شامل تصاویری از این اعداد است، دانلود کنیم:

```Python
from fastai.vision.all import *
path = untar_data(URLs.MNIST_SAMPLE) 
```
ما می‌توانیم با استفاده از ls، یک روش اضافه شده توسط fastai، محتوای این دایرکتوری را ببینیم. این روش یک شیء از کلاس ویژه‌ای از fastai به نام L برمی‌گرداند که تمام قابلیت‌های لیست ساخته‌شده‌ی پایتون را دارد، علاوه بر بسیاری از ویژگی‌های بیشتر. یکی از ویژگی‌های کاربردی آن این است که وقتی چاپ می‌شود، تعداد آیتم‌ها را نمایش می‌دهد قبل از اینکه آیتم‌ها را لیست کند (اگر بیش از 10 آیتم وجود داشت، فقط چندین آیتم اول را نشان می‌دهد).

```Python
path.ls()
```
```diff
(#3) [Path('/root/.fastai/data/mnist_sample/train'),Path('/root/.fastai/data/mnist_sample/labels.csv'),Path('/root/.fastai/data/mnist_sample/valid')]
```
مجموعه داده MNIST پیاده‌سازی رایج برای مجموعه داده‌های یادگیری ماشین را دنبال می‌کند: پوشه‌های جداگانه برای مجموعه train و مجموعه validation (و/یا test ). بیایید ببینیم چه چیزی داخل مجموعه آموزش قرار دارد:
```Python
(path/'train').ls()
```
```diff
(#2) [Path('/root/.fastai/data/mnist_sample/train/7'),Path('/root/.fastai/data/mnist_sample/train/3')]
```

پوشه‌ای از 3‌ها و یک پوشه‌ی دیگر از 7‌ها وجود دارد. در زبان یادگیری ماشین، می‌گوییم که “3” و “7” برچسب‌ها (یا اهداف) در این مجموعه داده هستند. بیایید به یکی از این پوشه ها نگاه کنیم (با استفاده از sorted  اطمینان داریم از اینکه ترتیب ما با ترتیب اصلی یکسان است):
```Python
threes = (path/'train'/'3').ls().sorted()
sevens = (path/'train'/'7').ls().sorted()
threes
```
```diff
(#6131) [Path('train/3/10.png'),Path('train/3/10000.png'),Path('train/3/10011.pn
> g'),Path('train/3/10031.png'),Path('train/3/10034.png'),Path('train/3/10042.p
> ng'),Path('train/3/10052.png'),Path('train/3/1007.png'),Path('train/3/10074.p
> ng'),Path('train/3/10091.png')...]
```
همانطور که انتظار داشتیم، پر از فایل‌های تصویر است. بیایید یکی را ببینیم. اینجا یک تصویر از عدد دست‌نویس ۳ است که از مجموعه معروف MNIST از اعداد دست‌نویس گرفته شده است:
```Python
im3_path = threes[1]
im3 = Image.open(im3_path)
im3
```

<img src='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAAAAABXZoBIAAAA9ElEQVR4nM3Or0sDcRjH8c/pgrfBVBjCgibThiKIyTWbWF1bORhGwxARxH/AbtW0JoIGwzXRYhJhtuFY2q1ocLgbe3sGReTuuWbwkx6+r+/zQ/pncX6q+YOldSe6nG3dn8U/rTQ70L8FCGJUewvxl7NTmezNb8xIkvKugr1HSeMP6SrWOVkoTEuSyh0Gm2n3hQyObMnXnxkempRrvgD+gokzwxFAr7U7YXHZ8x4A/Dl7rbu6D2yl3etcw/F3nZgfRVI7rXM7hMUUqzzBec427x26rkmlkzEEa4nnRqnSOH2F0UUx0ePzlbuqMXAHgN6GY9if5xP8dmtHFfwjuQAAAABJRU5ErkJggg=='>


در اینجا ما از کلاس Image  کتابخانه تصاویر پایتون  (PIL) استفاده می‌کنیم، که بسته پایتون بیشترین استفاده را برای باز کردن، تغییر دادن و مشاهده تصاویر دارد. Jupyter درباره تصاویر PIL آگاه است، بنابراین تصویر را برای ما به صورت خودکار نمایش می‌دهد. در کامپیوتر، همه چیز به صورت یک عدد نشان داده می‌شود. برای دیدن اعداد که این تصویر را تشکیل می‌دهند، باید آن را به آرایه‌ای NumPy یا تنسور PyTorch تبدیل کنیم. به عنوان مثال، در زیر  بخشی از تصویر بعد از تبدیل شدن به آرایه‌ای NumPy مشاهده می شود:
```Python
array(im3)[4:10,4:10]
```
```
array([[ 0, 0, 0, 0, 0, 0],
[ 0, 0, 0, 0, 0, 29],
[ 0, 0, 0, 48, 166, 224],
[ 0, 93, 244, 249, 253, 187],
[ 0, 107, 253, 253, 230, 48],
[ 0, 3, 20, 20, 15, 0]], dtype=uint8)
```

4:10 نشان می‌دهد که ما سطرها را از شاخص 4 (شامل) تا 10 (غیر شامل) درخواست کرده‌ایم، و همین برای ستون‌ها هم صادق است. NumPy از بالا به پایین و از چپ به راست شماره‌گذاری می‌کند، بنابراین این بخش نزدیک گوشه بالا سمت چپ تصویر قرار دارد. در اینجا همان  به عنوان یک تنسور PyTorch آورده شده است:
```python
tensor(im3)[4:10,4:10]
```
```diff
tensor([[ 0, 0, 0, 0, 0, 0],
[ 0, 0, 0, 0, 0, 29],
[ 0, 0, 0, 48, 166, 224],
[ 0, 93, 244, 249, 253, 187],
[ 0, 107, 253, 253, 230, 48],
[ 0, 3, 20, 20, 15, 0]], dtype=torch.uint8)
```

ما می‌توانیم آرایه را برش دهیم تا فقط قسمت  بالای رقم را انتخاب کنیم، سپس از یک DataFrame Pandas برای کدگذاری رنگ مقادیر با استفاده از یک گرادیان استفاده کنیم، که به ما نشان می‌دهد چگونه تصویر از مقادیر پیکسل ایجاد شده است:
```python
im3_t = tensor(im3)
df = pd.DataFrame(im3_t[4:15,4:22])
df.style.set_properties(**{'font-size':'6pt'}).background_gradient('Greys')
```
<img src='https://s32.picofile.com/file/8478385126/Untitled.png'>

می‌توانید ببینید که پیکسل‌های سفید پس‌زمینه به عنوان عدد ۰ ذخیره شده‌اند، سیاه عدد ۲۵۵ است، و سایه های خاکستری بین دو عدد هستند. کل تصویر دارای ۲۸ پیکسل عرض و ۲۸ پیکسل ارتفاع است، که مجموعاً ۷۶۸ پیکسل است. (این بسیار کوچکتر از تصویری است که شما از دوربین تلفن همراه دریافت می‌کنید، که میلیون‌ها پیکسل دارد، اما اندازه مناسبی برای یادگیری اولیه و آزمایشات ما است.)

پس، حالا که شما دیدید تصویر چگونه برای کامپیوتر به نظر می‌رسد، بیایید هدفمان را به یاد آوریم: ایجاد یک مدل که بتواند ۳ ها و ۷ ها را تشخیص دهد. چگونه می‌توانید کامپیوتر را برای انجام این کار تشویق کنید؟
## اولین تلاش: شباهت پیکسلی

 اولین ایده به این صورت است:  یافتن مقدار میانگین  برای هر پیکسل از ۳ ها، سپس همین کار را برای ۷ ها انجام دهیم. این کار به ما دو میانگین گروهی می‌دهد، آنچه ما ممکن است  ۳ و ۷ ایده آل  نامگذاری کنیم. سپس، برای دسته‌بندی یک تصویر به عنوان یکی ارقام دیگر، می‌بینیم که تصویر بیشتر شبیه به کدام یک از این دو ایده آل است. این قطعاً به نظر می‌رسد بهتر از هیچ چیز باشد، بنابراین یک پایه خوب خواهد بود.
 
مرحله اول برای مدل ساده ما بدست آوردن میانگین مقادیر پیکسل برای هر یک از دو گروه ما است. در حین انجام این کار، بسیاری از تکنیک‌های جذاب برنامه‌نویسی عددی پایتون را یاد خواهیم گرفت!

بیایید یک تنسور حاوی تمام ۳ هایمان را که کنار هم قرار دارند بسازیم. ما قبلاً یاد گرفتیم چگونه یک تنسور حاوی یک تصویر را ایجاد کنیم. برای ایجاد یک تنسور حاوی تمام تصاویری در یک مسیر، ابتدا از یک  لیست پایتون برای ساخت یک لیست ساده از تنسورهای تصویری  استفاده می‌کنیم.

ما از Jupyter برای انجام برخی بررسی‌های کوچک در طول راه استفاده می‌کنیم - در این مورد، می خواهیم مطمئن شویم از اینکه تعداد موارد برگشتی منطقی به نظر می‌رسد:
```python
seven_tensors = [tensor(Image.open(o)) for o in sevens]
three_tensors = [tensor(Image.open(o)) for o in threes]
len(three_tensors),len(seven_tensors)
```
`
(6131, 6265)
`

ما همچنین بررسی خواهیم کرد که آیا یکی از تصاویر به درستی به نظر می‌رسد. از آنجا که حالا داریم تنسورها (که Jupyter به طور پیش فرض آنها را به عنوان مقادیر چاپ می‌کند)، به جای تصاویر PIL (که Jupyter به طور پیش فرض تصاویر را نمایش می‌دهد)استفاده می کنیم، نیاز داریم از تابع show_image در fastai برای نمایش آن استفاده کنیم:
```python
show_image(three_tensors[1]);
```

<img src='https://s32.picofile.com/file/8478385400/download_2_.png'>

برای هر موقعیت پیکسل، ما می‌خواهیم میانگین بر روی تمام تصاویر شدت پیکسل را محاسبه کنیم. برای انجام این کار، ابتدا تمام تصاویر موجود در این لیست را به یک تنسور سه بعدی تبدیل می‌کنیم. روش معمول برای توصیف چنین تنسوری این است که آن را تنسور رتبه ۳ می‌نامیم. ما اغلب نیاز داریم تا تنسورهای مجزا را  به یک تنسور واحد تبدیل کنیم. شگفت‌آور نیست که PyTorch دارای یک تابع به نام stack است که می‌توانیم برای این منظور از آن استفاده کنیم.

بعضی عملیات‌ها در PyTorch، مانند محاسبه میانگین، نیاز دارند که اعداد صحیح  را به اعداد اعشاری تبدیل کند. از آنجا که ما به این کار  در آینده نیاز خواهیم داشت، پس تنسورهایمان را به حالت اعشاری تبدیل می‌کنیم. تبدیل در PyTorch به سادگی نوشتن نام نوعی است که می‌خواهیم تبدیل کنیم، و رفتار کردن با آن به عنوان یک متد.

عموماً، وقتی تصاویر اعشاری هستند، مقادیر پیکسل انتظار می‌رود بین ۰ و ۱ باشند، بنابراین ما همچنین در اینجا تقسیم بر ۲۵۵ خواهیم کرد:
```python
stacked_sevens = torch.stack(seven_tensors).float()/255
stacked_threes = torch.stack(three_tensors).float()/255
stacked_threes.shape
```
`
torch.Size([6131, 28, 28])
`

مهمترین ویژگی یک تنسور شکل آن است. این به شما می‌گوید که طول هر محور چقدر است. در این مورد، می‌توانیم ببینیم که ما ۶٬۱۳۱ تصویر داریم، هر کدام با اندازه ۲۸×۲۸ پیکسل. هیچ چیزی خاصی در مورد این تنسور وجود ندارد بجز آن که بگوید محور اول تعداد تصاویر است، دوم ارتفاع، و سوم عرض . برای PyTorch، این فقط یک سری اعداد در حافظه است.

طول شکل یک تنسور، رتبه آن است:
```python
len(stacked_threes.shape)
```
`
3
`

ما همچنین می‌توانیم رتبه یک تنسور را مستقیماً با استفاده از ndim بدست آوریم:
```python
stacked_threes.ndim
```
`3`


در نهایت، ما می‌توانیم محاسبه کنیم که چگونه ۳ ایده آل به نظر می‌رسد. ما میانگین تمام تنسورهای تصویر را با گرفتن میانگین در بعد ۰ از تنسور ما که مرتبه ۳ است، محاسبه می‌کنیم. این بعد است که بر روی تمام تصاویر شاخص‌گذاری می‌کند.

به عبارت دیگر، برای هر موقعیت پیکسل، این محاسبه، میانگین آن پیکسل را بر روی تمام تصاویر انجام می‌دهد. نتیجه یک مقدار برای هر موقعیت پیکسل، یا یک تصویر واحد خواهد بود. در اینجا آن است:
```python
mean3 = stacked_threes.mean(0)
show_image(mean3);
```
<img src='https://s32.picofile.com/file/8478386684/download_3_.png'>

بر اساس این مجموعه داده، این عدد ۳ ایده آل است! (شاید آنرا دوست نداشته باشید، اما این  ۳ایده آل است.)

بیایید همین کار را برای ۷ ها انجام دهیم، اما تمام مراحل را به طور همزمان اجرا کنیم تا زمان صرفه جویی شود:
```python
mean7 = stacked_sevens.mean(0)
show_image(mean7);
```
<img src='https://s32.picofile.com/file/8478386742/download_4_.png'>

بیایید حالا یک عدد ۳ تصادفی را انتخاب کنیم و فاصله آن را از ایده آلهایمان اندازه‌گیری کنیم.

اینجا یک سه نمونه داریم:
```python
a_3 = stacked_threes[1]
show_image(a_3);
```
<img src='https://s32.picofile.com/file/8478385400/download_2_.png'>


چگونه می‌توانیم فاصله آن را از ۳ ایده آلمان تعیین کنیم؟ ما نمی‌توانیم فقط تفاوت‌هایی را که بین پیکسل‌های این تصویر و ارقام تصویر ایده آل وجود دارد جمع کنیم. بعضی تفاوت‌ها مثبت خواهند بود، در حالی که دیگران منفی خواهند بود، و این تفاوت‌ها با هم لغو می‌شوند، منجر به این می‌شود که یک تصویر که در برخی مکان‌ها خیلی تیره است و در دیگران خیلی روشن است ممکن است به عنوان داشتن صفر کلی تفاوت با ایده آل نشان داده شود. این می‌تواند گمراه‌کننده باشد!


برای جلوگیری از این موضوع، دانشمندان داده از دو روش اصلی برای اندازه‌گیری فاصله در این زمینه استفاده می‌کنند:

محاسبه میانگین قدر مطلق تفاوت‌ها (قدر مطلق تابعی است که مقادیر منفی را با مقادیر مثبت جایگزین می‌کند). این به  نرم  L1 شناخته می‌شود.

محاسبه میانگین مربع اختلاف ها (که اختلاف ها را به توان دو می رساند) و سپس میانگین می گیرد . این به نام خطای میانگین مربعات ر(RMSE) یا نرم L2 شناخته می‌شود.

بیایید هر دو روش را امتحان کنیم:
```python 
dist_3_abs = (a_3 - mean3).abs().mean()
dist_3_sqr = ((a_3 - mean3)**2).mean().sqrt()
dist_3_abs,dist_3_sqr
```
`(tensor(0.1114), tensor(0.2021))`
```python
dist_7_abs = (a_3 - mean7).abs().mean()
dist_7_sqr = ((a_3 - mean7)**2).mean().sqrt()
dist_7_abs,dist_7_sqr
```
`(tensor(0.1586), tensor(0.3021))`

در هر دو حالت، فاصله بین ۳ ما و ۳ ایده آل کمتر از فاصله تا ۷ ایده آل است، بنابراین مدل ساده ما در این مورد پیش‌بینی درست خواهد داشت.
PyTorch هر دوی این‌ کارها را با یک تابع انجام می دهد. شما این‌ها را درون torch.nn.functional پیدا خواهید کرد، که تیم PyTorch توصیه می‌کند به عنوان F وارد شود (و به طور پیش فرض تحت آن نام در fastai در دسترس است):

```python
F.l1_loss(a_3.float(),mean7), F.mse_loss(a_3,mean7).sqrt()
```
`(tensor(0.1586), tensor(0.3021))`


